<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>IO Calculator</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net">
<style>
  :root{--b:#111;--bg:#fff;--muted:#666;--br:#eee}
body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
               Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
  background: #0B3048; /* deep navy blue from your logo */
  margin:0;
  padding:1rem 1.25rem;
  max-width:none;
}

.app-header {
  display:flex;
  align-items:center;
  gap:.75rem;
  margin-bottom:1rem;
}

.app-header .logo {
  height:42px;          /* tweak to taste */
  width:auto;
  border-radius:6px;    /* optional, soften corners */
}

h1 {
  font-size:1.6rem;
  margin:0;
  color:#fff;           /* white text on dark bg */
}

/* Cards pop against dark bg */
.card {
  border:1px solid #ddd;
  border-radius:12px;
  padding:1rem;
  background:#fff;
}


  .tabs{display:flex;gap:.5rem;border-bottom:1px solid var(--br);margin-bottom:1rem}
  .tab{padding:.6rem 1rem;border:1px solid var(--br);border-bottom:none;border-radius:10px 10px 0 0;background:#fafafa;cursor:pointer}
  .tab.active{background:#fff;border-color:var(--b);color:var(--b)}
  .panel{display:none}
  .panel.active{display:block}
  .grid{display:grid;gap:1rem}
  @media(min-width:900px){.filters{grid-template-columns:1fr 1fr 2fr}}
  select,input,button{padding:.6rem;border:1px solid var(--br);border-radius:10px;background:#fff}
  button{cursor:pointer}
  button.primary{background:var(--b);color:#fff;border-color:var(--b)}
  button:disabled{opacity:.5;cursor:not-allowed}
  .card{border:1px solid var(--br);border-radius:12px;padding:1rem;background:#fff}
  .muted{color:var(--muted);font-size:.92rem}
  table{width:100%;border-collapse:collapse}
  th,td{padding:.55rem;border-bottom:1px solid var(--br);text-align:left;white-space:nowrap}
  th:last-child, td:last-child{text-align:right}
  thead th{position:sticky;top:0;background:#f9f9f9}
  .table-wrap{max-height:420px;overflow:auto;border:1px solid var(--br);border-radius:12px}
  .kpis{display:grid;gap:.6rem;grid-template-columns:repeat(3,minmax(0,1fr))}
  .kpi{border:1px solid var(--br);border-radius:12px;padding:.8rem;background:#fff}
  .kpi .v{font-weight:700;font-size:1.15rem}
  .row{display:flex;gap:.6rem;align-items:flex-end}
.effects-header{
  display:flex;
  justify-content:space-between;
  align-items:center;
}

.effects-title{
  margin:0;
  font-size:1.1rem;      /* same size as you wanted */
  font-weight:700;
  letter-spacing:.01em;
}

.effects-controls{
  display:flex;
  align-items:center;    /* vertically center label + select + button */
  gap:.5rem;
}

.metric-label{
  margin:0 .5rem 0 0;
  font-size:1.1rem;      /* matches INDUSTRY EFFECTS */
  font-weight:700;
  letter-spacing:.02em;
  text-transform:uppercase;
}

.metric-select{
  padding:.4rem .6rem;   /* keeps options inside box */
  font-size:1rem;
  line-height:1.2;
  height:2.25rem;        /* gives consistent control height */
}

.btn{
  padding:.6rem 1rem;
  border:1px solid var(--br);
  border-radius:10px;
  background:#fff;
  cursor:pointer;
}

</style>
<header class="app-header">
  <img src="./data/NHEcrop.png" alt="Logo" class="logo">
  <h1>GB INPUT-OUTPUT CALCULATOR</h1>
</header>

  <div class="tabs">
    <button class="tab active" data-tab="inputs">Inputs</button>
    <button class="tab" data-tab="outputs">Outputs</button>
  </div>

  <!-- INPUTS PANEL -->
  <section class="panel active" id="inputs">
  
    <div class="grid filters card">
      <div>
        <label>GROUP</label>
        <select id="group"><option value="">Select...</option></select>
      </div>
      <div>
        <label>INPUT TYPE</label>
        <select id="type"><option value="">Select...</option></select>
      </div>
      <div>
        <label>CATEGORY</label>
        <select id="category"><option value="">Select...</option></select>
      </div>
    </div>

  <div class="card">
  <div class="grid" style="grid-template-columns:2fr 1fr; align-items:end;">
    <div>
      <label>INPUT VALUE</label>
      <input id="value" type="number" step="any" value="0" placeholder="Enter any number (±)">
    </div>
    <div class="row">
      <button id="addBtn" class="primary" disabled>Add</button>
      <button id="clearBtn">Clear</button>
      <button id="downloadInputsBtn">Download Inputs CSV</button>
    </div>
  </div>
</div>

    <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:.5rem">
        <h2 style="margin:0;font-size:1.1rem">Current Inputs</h2>
      </div>
      <div class="table-wrap">
        <table>
          <thead>
            <tr>
              <th>GROUP</th>
              <th>TYPE</th>
              <th>INDUSTRY &amp; DEMAND CATEGORY</th>
              <th>VALUE</th>
            </tr>
          </thead>
          <tbody id="tbody"><tr><td colspan="4" class="muted">No inputs yet.</td></tr></tbody>
        </table>
      </div>
      </div>
  </section>

<!-- OUTPUTS PANEL -->
<section class="panel" id="outputs">

  <div class="kpis" style="margin:.8rem 0 1rem">
    <div class="kpi"><div class="l">Total ΔGVA (£m)</div><div class="v" id="k_total_gva">–</div></div>
    <div class="kpi"><div class="l">Total ΔFTE</div><div class="v" id="k_total_fte">–</div></div>
    <div class="kpi"><div class="l">Total Growth (%)</div><div class="v" id="k_total_growth">–</div></div>
  </div>

  <div class="card" style="margin-bottom:1rem">
    <div class="effects-header">
      <h2 class="effects-title">INDUSTRY EFFECTS</h2>
      <div class="effects-controls">
        <label for="metric" class="metric-label">METRIC</label>
        <select id="metric" class="metric-select">
          <option value="gva">GVA</option>
          <option value="fte">FTE</option>
          <option value="growth">GROWTH</option>
        </select>
        <button id="downloadTableBtn" class="btn">Download table CSV</button>
      </div>
    </div>

    <div class="table-wrap" style="margin-top:.5rem">
      <table id="effectsTable">
       <thead>
  <tr>
    <th>INDUSTRY</th>
    <th>INITIAL</th>
    <th>DIRECT<br>SUPPLIERS</th>
    <th>INDIRECT<br>SUPPLIERS</th>
    <th>INCOME<br>INDUCED</th>
    <th>TOTAL</th>
  </tr>
</thead>
        <tbody id="effectsBody"></tbody>
      </table>
    </div>
  </div>

  <div class="card" style="height:560px">
    <h3 id="chartTitle" style="margin-top:0">ΔGVA by industry</h3>
    <canvas id="chartMain"></canvas>
  </div>

</section>



  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>

<script>
/*** ---------- Small helpers ---------- ***/
const fmt = {
  num: (x, dp=1) => (x===0? "0" : (x? Number(x).toLocaleString(undefined,{maximumFractionDigits:dp}) : "–")),
  money: (x, dp=1) => x==null? "–" : "£" + Number(x).toLocaleString(undefined,{maximumFractionDigits:dp}),
  pct: (x, dp=2) => x==null? "–" : Number(x).toLocaleString(undefined,{maximumFractionDigits:dp}) + "%"
};

const uniq = (arr)=>[...new Set(arr)];
const sum = (arr)=>arr.reduce((a,b)=>a+(+b||0),0);
const zeros = n => Array(n).fill(0);
const dot = (M, v) => {
  // M: m x n, v: n
  const m = M.length, n = v.length;
  const out = new Array(m).fill(0);
  for (let i=0;i<m;i++){
    let s=0; const row=M[i];
    for (let j=0;j<n;j++) s += row[j]*v[j];
    out[i]=s;
  }
  return out;
};
const sub = (a,b)=>a.map((x,i)=>x-b[i]);
const add = (a,b)=>a.map((x,i)=>x+b[i]);
const mulElem = (a,b)=>a.map((x,i)=>x*b[i]); // elementwise
const scale = (a,k)=>a.map(x=>x*k);

/*** ---------- Load CSV/JSON data ---------- ***/
async function getText(p){ const r = await fetch(p); if(!r.ok) throw new Error(p); return r.text(); }
function parseCSV(text){
  // simple CSV parser (commas, quoted cells)
  const rows = [];
  let i=0, cell='', row=[], inQ=false;
  while(i<text.length){
    const c=text[i];
    if(inQ){
      if(c==='\"' && text[i+1]==='\"'){ cell+='\"'; i+=2; continue; }
      if(c==='\"'){ inQ=false; i++; continue; }
      cell+=c; i++; continue;
    } else {
      if(c==='\"'){ inQ=true; i++; continue; }
      if(c===','){ row.push(cell); cell=''; i++; continue; }
      if(c==='\n' || c==='\r'){ if(cell!==''||row.length){ row.push(cell); cell=''; if(row.some(x=>x!=='')) rows.push(row); row=[]; } i++; continue; }
      cell+=c; i++; continue;
    }
  }
  if(cell!==''||row.length){ row.push(cell); if(row.some(x=>x!=='')) rows.push(row); }
  // header + rows -> objects
  const header = rows[0].map(h=>h.trim());
  return rows.slice(1).map(r=>{
    const o={}; header.forEach((h,idx)=>o[h]=r[idx]!==undefined?r[idx].trim():''); return o;
  });
}

async function loadAll(){
  const [
    inputList,
    baseIndCSV, baseDemCSV, fteCSV, sharesCSV, gvaCSV,
    A_csv, L1_csv, L2_csv
  ] = await Promise.all([
    fetch('./data/inputtable.json').then(r=>r.json()),
    getText('./data/baseline_industries_template.csv'),
    getText('./data/baseline_demand_template.csv'),
    getText('./data/fte_per_m_template.csv'),
    getText('./data/demand_share_vectors_template.csv'),
    getText('./data/gva_per_m_template.csv'),
    getText('./data/a_matrix.csv'),
    getText('./data/L1_matrix.csv'),
    getText('./data/L2_matrix.csv'),
  ]);

  const baseInd = parseCSV(baseIndCSV).map(r=>({industry:r.industry, baseline: +r.baseline_gbp_m}));
  const baseDem = parseCSV(baseDemCSV).map(r=>({demand:r.demand_category, baseline:+r.baseline_gbp_m}));
  const ftePerM = parseCSV(fteCSV).map(r=>({industry:r.industry, fte:+r.fte_per_m}));
  const gvaPerM = parseCSV(gvaCSV).map(r=>({industry:r.industry, gva:+r.fte_per_m})); // column header was fte_per_m in your file; treat as GVA/£m
  const shareRows = parseCSV(sharesCSV);

  const industries = baseInd.map(r=>r.industry);
  const demandCats = baseDem.map(r=>r.demand);
  // build shares: demand -> vector[industry]
  const shares = {};
  for(const row of shareRows){
    const d = row['demand_category'];
    if(!d) continue;
    const v = industries.map(ind => +row[ind] || 0);
    shares[d]=v;
  }

  function parseMatrix(csvText){
    // robust CSV -> numeric 2D array (21x21)
    const rows = csvText.trim().split(/\r?\n/).map(line=>line.split(',').map(x=>+x));
    return rows;
  }
  const A  = parseMatrix(A_csv);
  const L1 = parseMatrix(L1_csv);
  const L2 = parseMatrix(L2_csv);

  // Baseline totals
  const baselineOutputByInd = baseInd.map(r=>r.baseline||0);
  const baselineTotalOutput = sum(baselineOutputByInd);

  // fte/gva maps aligned to industries order
  const fteMap = {}; ftePerM.forEach(x=>{ fteMap[x.industry]=x.fte; });
  const gvaMap = {}; gvaPerM.forEach(x=>{ gvaMap[x.industry]=x.gva; });
  const ftePerInd = industries.map(ind => (fteMap[ind] ?? 0));
  const gvaPerInd = industries.map(ind => (gvaMap[ind] ?? 0));

  return { inputList, industries, demandCats, shares, baselineOutputByInd, baselineTotalOutput, ftePerInd, gvaPerInd, A, L1, L2 };
}

/*** ---------- Inputs UI ---------- ***/
const els = {
  group: document.getElementById('group'),
  type: document.getElementById('type'),
  category: document.getElementById('category'),
  value: document.getElementById('value'),
  addBtn: document.getElementById('addBtn'),
  clearBtn: document.getElementById('clearBtn'),
  tbody: document.getElementById('tbody'),
  metric: document.getElementById('metric'),
  k_total_output: document.getElementById('k_total_output'),
  k_total_gva: document.getElementById('k_total_gva'),
  k_total_fte: document.getElementById('k_total_fte'),
  k_total_growth: document.getElementById('k_total_growth'),
  effectsBody: document.getElementById('effectsBody'),
  downloadInputsBtn: document.getElementById('downloadInputsBtn'),
  downloadTableBtn: document.getElementById('downloadTableBtn'),
};

let DATA = null;        // loaded config & matrices
let entries = [];       // {group,type,category,value}

/*** Tabs ***/
document.querySelectorAll('.tab').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    document.querySelectorAll('.tab').forEach(b=>b.classList.remove('active'));
    document.querySelectorAll('.panel').forEach(p=>p.classList.remove('active'));
    btn.classList.add('active');
    document.getElementById(btn.dataset.tab).classList.add('active');
  });
});

/*** Load data then init inputs ***/
loadAll().then(cfg=>{
  DATA = cfg;
  initInputs(cfg.inputList);
}).catch(e=>{
  alert('Failed to load data files in /data. Check filenames/paths.');
  console.error(e);
});

function initInputs(list){
  const groups = uniq(list.map(d=>d.group)).sort();
  groups.forEach(g=>{ const o=document.createElement('option'); o.value=o.textContent=g; els.group.appendChild(o); });

  function syncTypes(){
    const scoped = els.group.value ? list.filter(d=>d.group===els.group.value) : list;
    els.type.innerHTML = '<option value="">Select...</option>';
    uniq(scoped.map(d=>d.type)).sort().forEach(t=>{ const o=document.createElement('option'); o.value=o.textContent=t; els.type.appendChild(o); });
  }
  function syncCats(){
    let scoped = list;
    if(els.group.value) scoped = scoped.filter(d=>d.group===els.group.value);
    if(els.type.value)  scoped = scoped.filter(d=>d.type===els.type.value);
    els.category.innerHTML = '<option value="">Select...</option>';
    uniq(scoped.map(d=>d.category)).sort().forEach(c=>{ const o=document.createElement('option'); o.value=o.textContent=c; els.category.appendChild(o); });
  }

  function validate(){
    const ok = els.group.value && els.type.value && els.category.value && els.value.value!=='' && !Number.isNaN(Number(els.value.value));
    els.addBtn.disabled = !ok;
  }

  els.group.addEventListener('change', ()=>{ els.type.value=''; els.category.value=''; syncTypes(); syncCats(); validate(); });
  els.type.addEventListener('change', ()=>{ els.category.value=''; syncCats(); validate(); });
  els.category.addEventListener('change', validate);
  els.value.addEventListener('input', validate);

  syncTypes(); syncCats(); validate();

  els.addBtn.addEventListener('click', ()=>{
  entries.unshift({ group: els.group.value, type: els.type.value, category: els.category.value, value: Number(els.value.value) });
  els.value.value = '0';
  renderEntries();
  calculateAll(); // <-- auto-calc after every add
});

els.clearBtn.addEventListener('click', ()=>{
  entries = [];
  renderEntries();
  calculateAll(); // <-- auto-calc after clear
});

function renderEntries(){
  const tb = els.tbody;
  tb.innerHTML = '';
  if(!entries.length){
    const tr=document.createElement('tr'); const td=document.createElement('td');
    td.colSpan=4; td.textContent='No inputs yet.'; td.className='muted'; tr.appendChild(td); tb.appendChild(tr);
  } else {
    entries.forEach(e=>{
      const tr=document.createElement('tr');
      tr.innerHTML = `<td>${e.group}</td><td>${e.type}</td><td>${e.category}</td><td style="text-align:right">${fmt.num(e.value,2)}</td>`;
      tb.appendChild(tr);
    });
  }
}
} // <-- CLOSES initInputs

/*** ---------- Conversion engine ---------- ***/
function buildInitialVector(){
  const { industries, demandCats, shares, baselineOutputByInd, ftePerInd } = DATA;
  const n = industries.length;
  const idxInd = Object.fromEntries(industries.map((name,i)=>[name,i]));
  const idxDem = Object.fromEntries(demandCats.map((name,i)=>[name,i]));

  const demandBaseline = Object.fromEntries(DATA.demandCats.map((d,i)=>[d, DATA.baselineOutputByInd[i]])); // placeholder (we won’t use this mapping)
  // Actually use the dedicated baseline_demand file:
  const demBase = Object.fromEntries(DATA.demandCats.map((d,i)=>[d,0]));
  // Better: reconstruct from the parsed CSV:
  // We'll rebuild from loadAll scope:
  // build dedicated map in DATA for demand baselines during loadAll:
}

</script>

<script>
/*** Re-open script to finish after we have DATA ***/
function calculateAll(){
  const { industries, A, L1, L2, baselineOutputByInd, baselineTotalOutput, ftePerInd, gvaPerInd, demandCats } = DATA;
  const n = industries.length;
  const idxInd = Object.fromEntries(industries.map((name,i)=>[name,i]));
  const demBaseMap = DATA._demBaseMap;          // demand_category -> baseline £m
  const shares = DATA._sharesMap;               // demand_category -> [21 weights]

  // Build INITIAL from entries
  let INIT = zeros(n);

  for(const e of entries){
    if(e.group === 'INDUSTRY'){
      const i = idxInd[e.category];
      if(i==null) continue;
      if(e.type === '£m' || e.type === 'GBP' || e.type === 'GBP_m' || e.type === 'GBP millions'){
        INIT[i] += e.value;
      } else if(e.type === 'FTE'){
        const f = ftePerInd[i] || 0;
        INIT[i] += (f>0 ? (e.value / f) : 0);
      } else if(e.type === '%'){
        const base = baselineOutputByInd[i] || 0;
        INIT[i] += (e.value/100) * base;
      }
    } else if(e.group === 'DEMAND'){
      if(e.type === '£m' || e.type === 'GBP' || e.type === 'GBP_m' || e.type === 'GBP millions'){
        const w = shares[e.category] || zeros(n);
        INIT = add(INIT, scale(w, e.value));
      } else if(e.type === '%'){
        const base = demBaseMap[e.category] || 0;
        const pot = (e.value/100) * base;
        const w = shares[e.category] || zeros(n);
        INIT = add(INIT, scale(w, pot));
      } else {
        // FTE for DEMAND not allowed per your spec; ignore
      }
    }
  }

  // Effects
  const DIRECT = dot(A, INIT);                 // A * INIT
  const L1INIT = dot(L1, INIT);
  const L2INIT = dot(L2, INIT);
  const INDIRECT = sub(sub(L1INIT, INIT), DIRECT);
  const INCOME  = sub(L2INIT, L1INIT);
  const TOTAL   = L2INIT;

  // Build metric transforms
  const toGVA = v => mulElem(v, gvaPerInd);
  const toFTE = v => mulElem(v, ftePerInd);
  const toGrowth = v => v.map((x,i)=> baselineOutputByInd[i]>0 ? (100 * x / baselineOutputByInd[i]) : 0);

  // Summaries
  const sumOutput = {
    initial: sum(INIT), direct: sum(DIRECT), indirect: sum(INDIRECT), income: sum(INCOME), total: sum(TOTAL)
  };
  const sumGVA = {
    initial: sum(toGVA(INIT)), direct: sum(toGVA(DIRECT)), indirect: sum(toGVA(INDIRECT)), income: sum(toGVA(INCOME)), total: sum(toGVA(TOTAL))
  };
  const sumFTE = {
    initial: sum(toFTE(INIT)), direct: sum(toFTE(DIRECT)), indirect: sum(toFTE(INDIRECT)), income: sum(toFTE(INCOME)), total: sum(toFTE(TOTAL))
  };
  const totalGrowthPct = (100 * sumOutput.total / (baselineTotalOutput || 1));

  // KPIs
  els.k_total_gva.textContent    = fmt.money(sumGVA.total,1);
  els.k_total_fte.textContent    = fmt.num(sumFTE.total,0);
  els.k_total_growth.textContent = fmt.pct(totalGrowthPct,2);

  // Table renderer for selected metric
  function getMetricVecs(metric){
    const convert = metric==='gva'? toGVA : metric==='fte'? toFTE : toGrowth;
    return {
      initial: convert(INIT),
      direct:  convert(DIRECT),
      indirect:convert(INDIRECT),
      income:  convert(INCOME),
      total:   convert(TOTAL),
      totalRowValue: (metric==='gva'? sumGVA.total : metric==='fte'? sumFTE.total : totalGrowthPct)
    };
  }

function renderTable(metric){
  const mb = getMetricVecs(metric);
  const body = els.effectsBody;
  body.innerHTML = '';

  // ➜ 1 d.p. for GVA, 1 d.p. for FTE, 2 d.p. for Growth
  const fmtFn = metric==='growth'
    ? (x)=>fmt.pct(x, 2)
    : (metric==='gva'
        ? (x)=>fmt.money(x, 1)
        : (x)=>fmt.num(x, 1));   // FTE now 1 d.p.

  for(let i=0;i<industries.length;i++){
    const r = document.createElement('tr');
    r.innerHTML = `
      <td>${industries[i]}</td>
      <td>${fmtFn(mb.initial[i])}</td>
      <td>${fmtFn(mb.direct[i])}</td>
      <td>${fmtFn(mb.indirect[i])}</td>
      <td>${fmtFn(mb.income[i])}</td>
      <td>${fmtFn(mb.total[i])}</td>
    `;
    body.appendChild(r);
  }

  const tr = document.createElement('tr');
  tr.style.fontWeight='700';
  tr.innerHTML = `<td>Total</td><td></td><td></td><td></td><td></td><td>${
    metric==='growth' ? fmt.pct(mb.totalRowValue, 2)
                      : (metric==='gva' ? fmt.money(mb.totalRowValue, 1)
                                         : fmt.num(mb.totalRowValue, 1))
  }</td>`;
  body.appendChild(tr);
}


  renderTable(els.metric.value);

// Chart (only one shown, based on metric)
renderChart(els.metric.value, industries, toGVA(TOTAL), toFTE(TOTAL), toGrowth(TOTAL), totalGrowthPct);

}

// CSV downloads
function downloadInputsCSV(){
  const rows = [['INPUT GROUP','INPUT TYPE','INDUSTRY & DEMAND CATEGORY','INPUT VALUE'],
    ...entries.map(e=>[e.group,e.type,e.category,String(e.value)])];
  const csv = rows.map(r=>r.map(c=>`"${String(c).replaceAll('"','""')}"`).join(',')).join('\n');
  const url = URL.createObjectURL(new Blob([csv],{type:'text/csv'}));
  const a = document.createElement('a'); a.href=url; a.download='inputs.csv'; a.click(); URL.revokeObjectURL(url);
}

function downloadTableCSV(){
  const table = document.getElementById('effectsTable');
  const rows = [...table.querySelectorAll('tr')].map(tr=>[...tr.children].map(td=>td.textContent));
  const csv = rows.map(r=>r.map(c=>`"${String(c).replaceAll('"','""')}"`).join(',')).join('\n');
  const url = URL.createObjectURL(new Blob([csv],{type:'text/csv'}));
  const a = document.createElement('a'); a.href=url; a.download=`effects_${document.getElementById('metric').value}.csv`; a.click(); URL.revokeObjectURL(url);
}
els.downloadTableBtn.addEventListener('click', downloadTableCSV);

// metric change
els.metric.addEventListener('change', ()=>calculateAll());



/*** Charts ***/
let chartMain;

function chartOpts(unitFormatter){
  return {
    indexAxis:'y',
    responsive:true,
    maintainAspectRatio:false,
    plugins:{
      legend:{ display:false },
      tooltip:{ callbacks:{ label:ctx=>' ' + unitFormatter(ctx.raw) } }
    },
    elements:{ bar:{ barThickness:12, maxBarThickness:14, borderRadius:4 } },
    scales:{
      y:{ ticks:{ autoSkip:false, maxRotation:0, minRotation:0 }, grid:{ display:false } },
      x:{ ticks:{ callback:value=>value } }
    },
    layout:{ padding:{ right:8 } }
  };
}

function renderChart(metric, labels, gvaVals, fteVals, growthVals, totalGrowth){
  const ctx = document.getElementById('chartMain').getContext('2d');
  if(chartMain) chartMain.destroy();

  let data, title, fmtUnit;
  if(metric === 'gva'){
    data = gvaVals;
    title = 'ΔGVA by industry';
    fmtUnit = v => fmt.money(v,1);
  } else if(metric === 'fte'){
    data = fteVals;
    title = 'ΔFTE by industry';
    fmtUnit = v => fmt.num(v,1);
  } else {
    // growth: add final 'Total' bar
    labels = [...labels, 'Total'];
    data = [...growthVals, totalGrowth];
    title = 'Growth by industry (incl. Total)';
    fmtUnit = v => fmt.pct(v,2);
  }

  document.getElementById('chartTitle').textContent = title;
  chartMain = new Chart(ctx, {
    type:'bar',
    data:{ labels, datasets:[{ data }] },
    options: chartOpts(fmtUnit)
  });
}


/*** Patch: stash demand baselines & shares after loadAll ***/
loadAll._patched = true;
</script>

<script>
/*** Finalize loader to expose demand baselines & shares for the engine ***/
(async function finalize(){
  const [
    baseDemCSV,
    sharesCSV
  ] = await Promise.all([
    fetch('./data/baseline_demand_template.csv').then(r=>r.text()),
    fetch('./data/demand_share_vectors_template.csv').then(r=>r.text())
  ]);
  const baseDem = (function(){ const r = (baseDemCSV||''); return r? (function(){ 
    const rows = r.trim().split(/\r?\n/); const h = rows.shift().split(',');
    const out={}; rows.forEach(line=>{ const cols=line.split(','); out[cols[0].trim()] = +cols[1]; }); return out; })() : {};
  })();
  const shareRows = (function(){ const r = (sharesCSV||''); return r? (function(){
    const rows = r.trim().split(/\r?\n/).map(line=>line.split(','));
    const header = rows.shift();
    const out={};
    rows.forEach(cols=>{
      const d = cols[0].trim();
      if(!d) return;
      out[d] = cols.slice(1).map(x=>+x||0);
    });
    return out;
  })(): {}; })();

  // Wait for main DATA to load
  const wait = ms=>new Promise(res=>setTimeout(res,ms));
  while(!DATA) await wait(50);

  DATA._demBaseMap = baseDem;
  DATA._sharesMap = shareRows;
})();
</script>

</body>
</html>
